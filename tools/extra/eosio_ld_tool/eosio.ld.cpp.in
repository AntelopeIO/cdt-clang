// Declares clang::SyntaxOnlyAction.
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include <boost/process.hpp>
#include <boost/filesystem.hpp>
#include <iostream>
#include <sstream>

// Declares llvm::cl::extrahelp.
#include "llvm/Support/CommandLine.h"
using namespace boost::process;
using namespace clang::tooling;
using namespace llvm;

// Apply a custom category to all command-line options so that they are the
// only ones displayed.
static llvm::cl::OptionCategory EosioLdToolCategory("eosio.ld options");

static cl::opt<std::string> eosio_imports_opt(
    "eosio-imports",
    cl::desc("Set the file for eosio.imports"),
    cl::Hidden,
    cl::cat(EosioLdToolCategory));
static cl::opt<std::string> pp_path_opt(
    "eosio-pp-dir",
    cl::desc("Set the directory for eosio.pp"),
    cl::Hidden,
    cl::cat(EosioLdToolCategory));
static cl::opt<bool> fno_lto_opt(
    "fno-lto",
    cl::desc("Disable LTO"),
    cl::cat(EosioLdToolCategory));
static cl::opt<bool> fno_cfl_aa_opt(
      "fno-cfl-aa",
      cl::desc("Disable CFL Alias Analysis"),
      cl::cat(EosioLdToolCategory));
static cl::opt<bool> fno_stack_first_opt(
      "fno-stack-first",
      cl::desc("Don't set the stack first in memory"),
      cl::cat(EosioLdToolCategory));
static cl::opt<bool> fno_post_pass_opt(
      "fno-post-pass",
      cl::desc("Don't run post processing pass"),
      cl::cat(EosioLdToolCategory));
static cl::opt<std::string> lto_opt_opt(
      "lto-opt",
      cl::desc("LTO Optimization level (O0-O3)"),
      cl::cat(EosioLdToolCategory));
static cl::list<std::string> L_opt(
    "L",
    cl::desc("Add directory to library search path"),
    cl::cat(EosioLdToolCategory),
    cl::Prefix,
    cl::ZeroOrMore);
static cl::list<std::string> l_opt(
    "l",
    cl::desc("Root name of library to link"),
    cl::cat(EosioLdToolCategory),
    cl::Prefix,
    cl::ZeroOrMore);
static cl::opt<std::string> o_opt(
    "o",
    cl::desc("Write output to <file>"),
    cl::cat(EosioLdToolCategory));
static cl::list<std::string> input_filename_opt(
      cl::Positional, 
      cl::desc("<input file> ..."), 
      cl::cat(EosioLdToolCategory),
      cl::OneOrMore);

struct Options {
   std::string linker;
   std::string output_fn;
   bool link;
   std::string eosio_pp_dir;
};

static Options CreateLDOptions() {
   std::stringstream link_ss;
   std::string output_fn;
   bool link = true;
   std::string pp_dir;

   link_ss << " --allow-undefined-file=${EOSIO_IMPORTS} -e apply ";
   link_ss << " --gc-sections --strip-all -zstack-size=${STACK_SIZE} ";
   link_ss << " --merge-data-segments ";
   link_ss << " -L../lib ";
   
   if (!pp_path_opt.empty())
      pp_dir = pp_path_opt;
   else
      pp_dir = ".";
   if (!eosio_imports_opt.empty())
      link_ss << " --allow-undefined-file=" << eosio_imports_opt << " ";
   else
      link_ss << " --allow-undefined-file=../lib/eosio.imports ";
   if (!fno_cfl_aa_opt) {
      link_ss << " -mllvm -use-cfl-aa-in-codegen=both ";
   }
   if (!fno_stack_first_opt) {
      link_ss << " -stack-first ";
   } 
   for ( auto input_filename : input_filename_opt )
      link_ss << input_filename << " ";
   if (fno_lto_opt) {
      link_ss << " --lto-O0 ";
      if (!lto_opt_opt.empty())
         std::cerr << "Warning : lto disabled but lto optimization level given\n";
   }
   else if (!lto_opt_opt.empty())
      link_ss << " --lto-" << lto_opt_opt << " ";
   else
      link_ss << " --lto-O3 ";
   for ( auto lib_dir : L_opt )
      link_ss << " -L" << lib_dir << " ";
   for ( auto library : l_opt )
      link_ss << " -l" << library << " ";
   if (o_opt.empty()) {
      link_ss << " -o a.out";
      output_fn = "a.out";
   }
   else {
      link_ss << " -o " << o_opt << " ";
      output_fn = o_opt;
   }
   link_ss << " -lc++ -lc -leosio ";

   return {link_ss.str(), output_fn, link, pp_dir};
}

int main(int argc, const char **argv) {

  cl::SetVersionPrinter([](llvm::raw_ostream& os) {
        os << "eosio.ld version " << ${EOSIO_VER_MAJOR} << "." << ${EOSIO_VER_MINOR} << "." << ${EOSIO_VER_REVISION} << "\n";
  });
  cl::ParseCommandLineOptions(argc, argv, "eosio.ld (WebAssembly linker)");
  Options opts = CreateLDOptions();

  std::string line;
  // link
  if (opts.link) {
     ipstream link_stream;
     std::string linkstr = std::string("./wasm-ld "+opts.linker);
     try {
        child link(linkstr.c_str(), std_out > link_stream);
        line = "";
        while (link_stream && std::getline(link_stream, line) && !line.empty())
           std::cerr << line << std::endl;
        link.wait();
     } catch ( boost::process::process_error& e ) {
        std::cerr << e.what() << "\n";
        return -1;
     }
  }

  if ( !boost::filesystem::exists( opts.output_fn.c_str() ) )
     return -1;

  // finally any post processing
  if (!fno_post_pass_opt) {
     ipstream final_stream;
     if ( !boost::filesystem::exists( opts.eosio_pp_dir+"/eosio.pp" ) ) {
        std::cerr << "Error: eosio.pp not found! (Try reinstalling eosio.wasmsdk)" << std::endl;
        return -1;
     }
        
     std::string finalstr = std::string(opts.eosio_pp_dir+"/eosio.pp "+opts.output_fn);
     try {
        child finalp(finalstr.c_str(), std_out > final_stream);
        line = "";
        while (final_stream && std::getline(final_stream, line) && !line.empty())
           std::cerr << line << std::endl;
        finalp.wait();
        if ( !boost::filesystem::exists( opts.output_fn.c_str() ) )
           return -1;
     } catch ( boost::process::process_error& e ) {
        std::cerr << e.what() << std::endl;
        return -1;
     }
   }
  return 0;
}
